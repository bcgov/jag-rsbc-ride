kafka.bootstrap.servers=${KAFKA-SERVER}:9092

mp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://apicurio-registry-5115cc-dev.apps.silver.devops.gov.bc.ca/api

# automatically register the schema with the registry, if not present
kafka.apicurio.registry.auto-register=true

# logging
quarkus.log.category."org.apache.kafka.clients".level=INFO
quarkus.log.category."org.apache.kafka.common.utils".level=INFO
quarkus.log.category."org.apache.kafka.common.metrics".level=INFO

# the default endpoint location is: /q/openapi
# quarkus.smallrye-openapi.path=/swagger

# By default, Swagger UI is only available when Quarkus is started in dev or test mode.
# If you want to make it available in production too, you can include the following configuration in your
quarkus.swagger-ui.always-include=true

##################################################################################
# Configuring the outgoing channel for publish evtIssuanceEvent (writing to Kafka)
##################################################################################
# set the connector for the outgoing channel to `smallrye-kafka`
mp.messaging.outgoing.outgoing-evtIssuanceEvent.connector=smallrye-kafka

# set the topic name for the channel to `evtIssuanceEvent`
mp.messaging.outgoing.outgoing-evtIssuanceEvent.topic=evtIssuanceEvent

mp.messaging.outgoing.outgoing-evtIssuanceEvent.value.serializer=io.apicurio.registry.utils.serde.AvroKafkaSerializer
mp.messaging.outgoing.outgoing-evtIssuanceEvent.apicurio.registry.artifact-id=io.apicurio.registry.utils.serde.strategy.SimpleTopicIdStrategy
mp.messaging.outgoing.outgoing-evtIssuanceEvent.apicurio.registry.global-id=io.apicurio.registry.utils.serde.strategy.GetOrCreateIdStrategy
mp.messaging.outgoing.outgoing-evtIssuanceEvent.apicurio.registry.avro-datum-provider=io.apicurio.registry.utils.serde.avro.ReflectAvroDatumProvider

# automatically register the schema with the registry, if not present
mp.messaging.outgoing.outgoing-evtIssuanceEvent.apicurio.registry.auto-register=true

# Enable both liveness and readiness checks (default is true)
mp.messaging.outgoing.outgoing-evtIssuanceEvent.health-enabled=true

# Enable only the readiness check with (default is true)
mp.messaging.outgoing.outgoing-evtIssuanceEvent.health-readiness-enabled=true

# If the message order is a must for your use case, setting max.in.flight.requests.per.connection to 1 
# which will make sure a single batch of messages is sent at a time, in the expense of limiting the throughput of the producer.
mp.messaging.outgoing.outgoing-evtIssuanceEvent.max.in.flight.requests.per.connection=1

##################################################################################
# Configuring the incoming channel for consume evtIssuanceEvent (writing to Kafka)
##################################################################################
# Configuring the incoming channel (read from Kafka)
mp.messaging.incoming.incoming-evtIssuanceEvent.connector=smallrye-kafka
mp.messaging.incoming.incoming-evtIssuanceEvent.topic=evtIssuanceEvent

mp.messaging.incoming.incoming-evtIssuanceEvent.value.deserializer=io.apicurio.registry.utils.serde.AvroKafkaDeserializer
mp.messaging.incoming.incoming-evtIssuanceEvent.apicurio.registry.avro-datum-provider=io.apicurio.registry.utils.serde.avro.ReflectAvroDatumProvider
# mp.messaging.incoming.incoming-evtIssuanceEvent.value.deserializer=io.apicurio.registry.serde.avro.AvroKafkaDeserializer

# Enable both liveness and readiness checks (default is true)
mp.messaging.incoming.incoming-evtIssuanceEvent.health-enabled=true

# Enable only the readiness check (default is true)
mp.messaging.incoming.incoming-evtIssuanceEvent.health-readiness-enabled=true

# What to do when there is no initial offset in Kafka. Accepted values are earliest, latest and none
mp.messaging.incoming.incoming-evtIssuanceEvent.auto.offset.reset=latest

# A unique string that identifies the consumer group the application belongs to. If not set, a unique, generated id is used
# mp.messaging.incoming.incoming-evtIssuanceEvent.group.id=consumerGroup1

#If enabled, consumerâ€™s offset will be periodically committed in the background by the underlying Kafka client, 
# ignoring the actual processing outcome of the records. It is recommended to NOT enable this setting 
# and let Reactive Messaging handles the commit.
mp.messaging.incoming.incoming-evtIssuanceEvent.enable.auto.commit=false
