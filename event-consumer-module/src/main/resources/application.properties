

#quarkus.swagger-ui.always-include=true
#quarkus.smallrye-openapi.info-title=RIDE Producer API
#quarkus.smallrye-openapi.info-version=1.0
#quarkus.smallrye-openapi.info-description=API for external systems to send events to RIDE
#quarkus.smallrye-openapi.info-terms-of-service=TBD
#quarkus.smallrye-openapi.info-contact-email=RSIOpsSupport@gov.bc.ca
#quarkus.smallrye-openapi.info-contact-name=RSO Ops Support
#quarkus.smallrye-openapi.info-contact-url=https://github.com/bcgov/jag-rsbc-ride
#quarkus.smallrye-openapi.info-license-name=Apache 2.0
#quarkus.smallrye-openapi.info-license-url=https://www.apache.org/licenses/LICENSE-2.0.html


# Kafka general parameters
kafka.bootstrap.servers=${KAFKA_SERVER}
kafka.security.protocol=${KAFKA_SEC_PROTOCOL}
kafka.sasl.mechanism=${KAFKA_SASL_MECH}
kafka.sasl.jaas.config=${KAFKA_SASL_CONFIG};
kafka.schema.registry.url=${KAFKA_SCHEMA_REGISTRY}


# Configuring Test event channel

mp.messaging.incoming.incoming-testevent.connector=smallrye-kafka
mp.messaging.incoming.incoming-testevent.topic=${TEST_EVENT_TOPIC}
mp.messaging.incoming.incoming-testevent.value.deserializer=io.apicurio.registry.utils.serde.AvroKafkaDeserializer
mp.messaging.incoming.incoming-testevent.apicurio.registry.artifact-id=io.apicurio.registry.utils.serde.strategy.SimpleTopicIdStrategy
mp.messaging.incoming.incoming-testevent.apicurio.registry.global-id=io.apicurio.registry.utils.serde.strategy.GetOrCreateIdStrategy
mp.messaging.incoming.incoming-testevent.apicurio.registry.avro-datum-provider=io.apicurio.registry.utils.serde.avro.ReflectAvroDatumProvider
mp.messaging.connector.smallrye-kafka.apicurio.registry.url=${KAFKA_SCHEMA_REGISTRY}
mp.messaging.incoming.incoming-testevent.ssl.protocol=${SSL_PROTOCOL}
mp.messaging.incoming.incoming-testevent.ssl.truststore.location=${SSL_TRUSTSTORE}
mp.messaging.incoming.incoming-testevent.ssl.truststore.password=${SSL_TRUSTTORE_PASS}
mp.messaging.incoming.incoming-testevent.ssl.truststore.type=${SSL_TRUSTTORE_TYPE}
mp.messaging.incoming.incoming-testevent.specific.avro.reader=true
mp.messaging.incoming.incoming-testevent.apicurio.registry.auto-register=true
mp.messaging.incoming.incoming-testevent.enable.auto.commit=false
mp.messaging.incoming.incoming-testevent.group.id=consumerGroup1
mp.messaging.incoming.incoming-testevent.partitions=1
mp.messaging.incoming.incoming-testevent.auto.offset.reset=latest



# Configuring outgoing Test event channel

mp.messaging.outgoing.outgoing-testevent.connector=smallrye-kafka
mp.messaging.outgoing.outgoing-testevent.topic=${TEST_EVENT_SINK_TOPIC}
mp.messaging.outgoing.outgoing-testevent.value.serializer=org.apache.kafka.common.serialization.StringSerializer
mp.messaging.outgoing.outgoing-testevent.ssl.protocol=${SSL_PROTOCOL}
mp.messaging.outgoing.outgoing-testevent.ssl.truststore.location=${SSL_TRUSTSTORE}
mp.messaging.outgoing.outgoing-testevent.ssl.truststore.password=${SSL_TRUSTTORE_PASS}
mp.messaging.outgoing.outgoing-testevent.ssl.truststore.type=${SSL_TRUSTTORE_TYPE}





# https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html#kafka-installation

# Configuring the incoming channel (read from Kafka)
#mp.messaging.incoming.incoming-channel.connector=smallrye-kafka
#mp.messaging.incoming.incoming-channel.topic=mock-etk-event
#mp.messaging.incoming.incoming-channel.key.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer
#mp.messaging.incoming.incoming-channel.value.deserializer=org.apache.kafka.common.serialization.StringDeserializer

# Enable both liveness and readiness checks (default is true)
#mp.messaging.incoming.incoming-channel.health-enabled=true

# Enable only the readiness check (default is true)
#mp.messaging.incoming.incoming-channel.health-readiness-enabled=true

# Configuring the application that consumes the messages
#endpointURL.consumer_application_mock=${MOCKSVC_URL}

# What to do when there is no initial offset in Kafka. Accepted values are earliest, latest and none
#mp.messaging.incoming.incoming-channel.auto.offset.reset=latest

# A unique string that identifies the consumer group the application belongs to. If not set, a unique, generated id is used
# mp.messaging.incoming.incoming-channel.group.id=consumerGroup1

#If enabled, consumerâ€™s offset will be periodically committed in the background by the underlying Kafka client,
# ignoring the actual processing outcome of the records. It is recommended to NOT enable this setting
# and let Reactive Messaging handles the commit.
#mp.messaging.incoming.incoming-channel.enable.auto.commit=false

# The number of partitions to be consumed concurrently. The connector creates the specified amount of Kafka consumers.
# It should match the number of partition of the targeted topic
# mp.messaging.incoming.incoming-channel.partitions=1